function QuizV1() { const [resultHtml, setResultHtml] = React.useState(''); const [loading, setLoading] = React.useState(true); const [error, setError] = React.useState(null); const [image1, setImage1] = React.useState(null); const [image2, setImage2] = React.useState(null); const [loadingImage1, setLoadingImage1] = React.useState(false); const [loadingImage2, setLoadingImage2] = React.useState(false); const styles = { container: { display: 'flex', flexDirection: 'column', maxWidth: '900px', margin: '0 auto', padding: '20px', fontFamily: 'Arial, sans-serif' }, resultContainer: { backgroundColor: '#fff', borderRadius: '8px', border: '1px solid #e0e0e0', padding: '20px', marginBottom: '30px' }, blocksContainer: { display: 'flex', justifyContent: 'space-between', flexWrap: 'wrap', gap: '20px' }, imageBlock: { width: '400px', backgroundColor: '#fff', borderRadius: '8px', border: '1px solid #e0e0e0', padding: '20px', display: 'flex', flexDirection: 'column', alignItems: 'center' }, blockTitle: { fontSize: '20px', fontWeight: 600, color: '#333', marginTop: 0, marginBottom: '15px', textAlign: 'center' }, imageContainer: { width: '100%', height: '600px', backgroundColor: '#f5f5f5', borderRadius: '4px', marginBottom: '15px', display: 'flex', justifyContent: 'center', alignItems: 'center', color: '#999', overflow: 'hidden' }, image: { width: '100%', height: '100%', objectFit: 'cover' }, imageText: { fontSize: '16px', lineHeight: '1.5', color: '#333', textAlign: 'center' }, refreshButton: { backgroundColor: '#0066cc', color: '#fff', border: 'none', borderRadius: '4px', padding: '12px 20px', fontSize: '16px', fontWeight: 500, cursor: 'pointer', margin: '20px auto', display: 'block' }, loadingContainer: { padding: '40px', textAlign: 'center', color: '#666' }, errorContainer: { padding: '20px', backgroundColor: '#fff1f0', borderRadius: '8px', border: '1px solid #ffccc7', marginTop: '20px' }, errorTitle: { color: '#cf1322', fontSize: '18px', fontWeight: 600, marginTop: 0, marginBottom: '10px' }, errorMessage: { color: '#333', fontSize: '16px', lineHeight: '1.5', margin: 0 } }; const fetchQuizResult = React.useCallback(async () => { try { setLoading(true); setError(null); const resultParam = urlParams?.result || ''; const response = await n8nFetch(`quiz/v1?result=${resultParam}`); const data = await response.json(); if (data && data.html) { setResultHtml(data.html); } else { throw new Error('Некорректный формат ответа от сервера'); } } catch (err) { console.error('Ошибка при загрузке результатов квиза:', err); setError(err.message || 'Произошла ошибка при загрузке результатов квиза'); } finally { setLoading(false); } }, [urlParams]); const fetchImages = React.useCallback(async () => { const resultParam = urlParams?.result || ''; const quizParam = urlParams?.quiz || ''; const controller = new AbortController(); const timeoutId = setTimeout(() => controller.abort(), 120000); const fetchImage1 = async () => { try { setLoadingImage1(true); const response = await n8nFetch(`quiz/v1-image1?result=${resultParam}&quiz=${quizParam}`, { signal: controller.signal }); const data = await response.json(); setImage1(data); } catch (err) { if (err.name === 'AbortError') { console.error('Превышено время ожидания ответа от сервера (2 минуты) для изображения 1'); } else { console.error('Ошибка при загрузке изображения 1:', err); } } finally { setLoadingImage1(false); } }; const fetchImage2 = async () => { try { setLoadingImage2(true); const response = await n8nFetch(`quiz/v1-image2?result=${resultParam}&quiz=${quizParam}`, { signal: controller.signal }); const data = await response.json(); setImage2(data); } catch (err) { if (err.name === 'AbortError') { console.error('Превышено время ожидания ответа от сервера (2 минуты) для изображения 2'); } else { console.error('Ошибка при загрузке изображения 2:', err); } } finally { setLoadingImage2(false); } }; fetchImage1(); fetchImage2(); return () => { clearTimeout(timeoutId); controller.abort(); }; }, [urlParams]); React.useEffect(() => { fetchQuizResult(); }, [fetchQuizResult]); if (loading) { return React.createElement('div', { style: styles.container }, React.createElement('div', { style: styles.loadingContainer }, React.createElement('p', null, 'Загрузка результатов квиза...') ) ); } if (error) { return React.createElement('div', { style: styles.container }, React.createElement('div', { style: styles.errorContainer }, React.createElement('h2', { style: styles.errorTitle }, 'Ошибка загрузки результатов'), React.createElement('p', { style: styles.errorMessage }, error) ) ); } return React.createElement('div', { style: styles.container }, React.createElement('div', { style: styles.resultContainer, dangerouslySetInnerHTML: { __html: resultHtml } }), React.createElement('div', { style: styles.blocksContainer }, React.createElement('div', { style: styles.imageBlock }, React.createElement('h2', { style: styles.blockTitle }, 'Мотивация'), React.createElement('div', { style: styles.imageContainer }, loadingImage1 ? 'Загрузка...' : image1 && image1.image ? React.createElement('img', { src: `data:image/jpeg;base64,${image1.image}`, alt: 'Мотивация', style: styles.image }) : 'Изображение не загружено' ), React.createElement('p', { style: styles.imageText }, loadingImage1 ? 'Загрузка...' : (image1 && image1.caption ? image1.caption : 'Нет описания') ) ), React.createElement('div', { style: styles.imageBlock }, React.createElement('h2', { style: styles.blockTitle }, 'Архитип'), React.createElement('div', { style: styles.imageContainer }, loadingImage2 ? 'Загрузка...' : image2 && image2.image ? React.createElement('img', { src: `data:image/jpeg;base64,${image2.image}`, alt: 'Архитип', style: styles.image }) : 'Изображение не загружено' ), React.createElement('p', { style: styles.imageText }, loadingImage2 ? 'Загрузка...' : (image2 && image2.caption ? image2.caption : 'Нет описания') ) ) ), React.createElement('button', { style: styles.refreshButton, onClick: fetchImages, disabled: loadingImage1 || loadingImage2 }, loadingImage1 || loadingImage2 ? 'Генерация...' : 'Генерировать обложки') );
}
const exportedComponent = QuizV1;
  
return exportedComponent;